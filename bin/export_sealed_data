#!/usr/bin/env ruby

require_relative "../search-engine/lib/card_database"

class ExportSealedData
  def initialize
    @db = CardDatabase.load
    @factory = PackFactory.new(@db)
  end

  def flatten_pack(pack)
    if pack.is_a?(WeightedPack)
      pack.flatten_weighted_pack
    else
      WeightedPack.new(pack => 1)
    end
  end

  def extract_sheets(pack)
    sheets = pack.packs.keys.map(&:sheets).flat_map(&:keys)
    sheets.map{|s| [s, @factory.sheet_cache.invert[s].join("_")] }.to_h
  end

  def serialize_subpack(pack, weight, sheets)
    {
      sheets: pack.sheets.map{|s,c| [sheets[s], c]}.to_h,
      weight: weight,
    }
  end

  def serialize_sheet(sheet)
    ev = sheet.probabilities
    # Normalize rationals to weights
    lcm = ev.values.map(&:denominator).inject(&:lcm)
    ev = ev.map{|k,v| vv = v*lcm; raise unless vv.to_i == vv; [k, vv.to_i] }.to_h

    cards = ev.sort_by{|e,w| [e.set_code, e.number, e.foil ? 0 : 1]}.map do |e,w|
      name = "#{e.set_code}:#{e.number}"
      name = "#{name}:foil" if e.foil
      [name, w]
    end.sort.to_h
    {
      partner: sheet.is_a?(PartnerCardSheet) ? true : nil,
      balance_colors: sheet.is_a?(ColorBalancedCardSheet) ? true : nil,
      cards: cards,
    }.compact
  end

  def serialize_sheets(sheets)
    sheets.map{|sheet, id|
      [id, serialize_sheet(sheet)]
    }.to_h
  end

  def call(output_path)
    exported_data = []
    @db.sets_with_packs.each do |set|
      pack = @factory.for(set.code)
      pack = flatten_pack(pack)
      sheets = extract_sheets(pack)
      exported_data << {
        name: set.name,
        code: set.code,
        boosters: pack.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets),
      }
    end
    open(output_path, "w") do |fh|
      fh.puts JSON.pretty_generate(exported_data)
    end
  end
end

output_path = ARGV[0] || "export_sealed.json"
ExportSealedData.new.call(output_path)
