#!/usr/bin/env python3

import datetime
import json
import more_itertools
import re

class CompRules:
    def __init__(self, comp_rules_f):
        lines = more_itertools.peekable(comp_rules_f)
        # title and date
        assert next(lines) == 'Magic: The Gathering Comprehensive Rules\n'
        assert next(lines) == '\n'
        match = re.fullmatch('These rules are effective as of ([A-Za-z]+) ([0-9]+), ([0-9]+).\n', next(lines))
        assert match
        year = int(match.group(3))
        month = [None, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].index(match.group(1))
        day = int(match.group(2))
        self.date = datetime.date(year, month, day)
        assert next(lines) == '\n'
        # header
        self.header = ''
        seen_contents_start = False
        for line in lines:
            if lines.peek() == '1. Game Concepts\n':
                if seen_contents_start:
                    break
                else:
                    seen_contents_start = True
            self.header += line
        # rules
        self.sections = []
        current_section = None
        current_subsection = None
        current_rule = ''
        is_subrule = False
        for line in lines:
            # paragraph break
            if re.fullmatch(' *\n', line):
                if current_rule != '':
                    if is_subrule:
                        current_subsection['rules'][-1]['subrules'].append(current_rule)
                    else:
                        current_subsection['rules'].append({
                            'subrules': [],
                            'text': current_rule
                        })
                if lines.peek() == 'Glossary\n':
                    current_section['subsections'].append(current_subsection)
                    self.sections.append(current_section)
                    break
                current_rule = ''
                continue
            # section header
            match = re.fullmatch('([0-9])\\. (.+)\n', line)
            if match:
                if current_subsection is not None:
                    current_section['subsections'].append(current_subsection)
                if current_section is not None:
                    self.sections.append(current_section)
                assert int(match.group(1)) == len(self.sections) + 1
                current_section = {
                    'name': match.group(2),
                    'subsections': []
                }
                current_subsection = None
                continue
            # subsection header
            match = re.fullmatch('([0-9]{3})\\. (.+)\n', line)
            if match:
                if current_subsection is not None:
                    current_section['subsections'].append(current_subsection)
                assert int(match.group(1)) // 100 == len(self.sections) + 1
                assert int(match.group(1)) % 100 == len(current_section['subsections'])
                current_subsection = {
                    'name': match.group(2),
                    'rules': []
                }
                continue
            # rule text
            if current_rule == '':
                match = re.fullmatch('([0-9]{3})\\.([0-9]+)[a-z] (.+)\n', line)
                is_subrule = bool(match)
                if is_subrule:
                    assert int(match.group(2)) == len(current_subsection['rules'])
                else:
                    match = re.fullmatch('([0-9]{3})\\.([0-9]+). (.+)\n', line)
                    assert int(match.group(2)) == len(current_subsection['rules']) + 1
                assert int(match.group(1)) // 100 == len(self.sections) + 1
                assert int(match.group(1)) % 100 == len(current_section['subsections'])
                current_rule += match.group(3)
            else:
                current_rule += '\n' + line[:-1]
        # footer
        self.footer = ''
        for line in lines:
            self.footer += line

    def apply_patch(self, patch_json):
        if parse_iso_date(patch_json['base']) != self.date:
            raise ValueError('This rules patch is for a different version of the rules')
        for patch in patch_json['patches']:
            if patch['type'] == 'addSubtypes':
                rule = self.sections[1]['subsections'][5]['rules'][2]
                subrule_id = {
                    'Artifact': 6,
                    'Creature': 11,
                    'Enchantment': 7,
                    'Land': 8,
                    'Plane': 12,
                    'Planeswalker': 9,
                    'Sorcery': 10
                }[patch['cardType']]
                subrule = rule['subrules'][subrule_id]
                if patch['cardType'] in ('Artifact', 'Enchantment', 'Creature', 'Plane', 'Sorcery'):
                    match = re.fullmatch('(.*)\\. The ([^ ]+) types are (.+).()', subrule)
                elif patch['cardType'] in ('Land', 'Planeswalker'):
                    match = re.fullmatch('(.*)\\. The ([^ ]+) types are (.+).(\n[^\n]*)', subrule)
                else:
                    raise NotImplementedError('Unknown card type: {!r}'.format(patch['cardType']))
                subtypes = {re.sub(' \\(.+\\)', '', subtype): subtype for subtype in split(match.group(3))}
                for new_subtype in patch['subtypes']:
                    assert new_subtype not in subtypes
                    subtypes[new_subtype] = new_subtype
                rule['subrules'][subrule_id] = '{}. The {} types are {}.{}'.format(match.group(1), match.group(2), join(v for k, v in sorted(subtypes.items())), match.group(4))
            else:
                raise NotImplementedError('Unknown patch type: {!r}'.format(patch['type']))

    def dump(self, comp_rules_f):
        # title and date
        comp_rules_f.write('Custom Magic Comprehensive Rules\n')
        comp_rules_f.write('\n')
        comp_rules_f.write('These rules are effective as of {0:%B} {1}, {0:%Y}.\n'.format(self.date, self.date.day))
        comp_rules_f.write('\n')
        # header
        comp_rules_f.write(self.header)
        # rules
        for i, section in enumerate(self.sections):
            section_number = i + 1
            comp_rules_f.write('\n')
            comp_rules_f.write('{}. {}\n'.format(section_number, section['name']))
            for j, subsection in enumerate(section['subsections']):
                subsection_number = 100 * section_number + j
                comp_rules_f.write('\n')
                comp_rules_f.write('{}. {}\n'.format(subsection_number, subsection['name']))
                for k, rule in enumerate(subsection['rules']):
                    rule_number = k + 1
                    comp_rules_f.write('\n')
                    comp_rules_f.write('{}.{}. {}\n'.format(subsection_number, rule_number, rule['text']))
                    for l, subrule in enumerate(rule['subrules']):
                        subrule_number = 'abcdefghijkmnpqrstuvwxyz'[l]
                        comp_rules_f.write('\n')
                        comp_rules_f.write('{}.{}{} {}\n'.format(subsection_number, rule_number, subrule_number, subrule))
        # footer
        #comp_rules_f.write(self.footer)

def join(sequence, *, word='and', default=None):
    sequence = [str(elt) for elt in sequence]
    if len(sequence) == 0:
        if default is None:
            raise IndexError('Tried to join empty sequence with no default')
        else:
            return str(default)
    elif len(sequence) == 1:
        return sequence[0]
    elif len(sequence) == 2:
        return '{} {} {}'.format(sequence[0], word, sequence[1])
    else:
        return ', '.join(sequence[:-1]) + ', {} {}'.format(word, sequence[-1])

def parse_iso_date(date_str):
    if isinstance(date_str, datetime.date):
        return date_str
    parts = date_str.split('-')
    if len(parts) != 3:
        raise ValueError('Failed to parse date from {!r} (format should be YYYY-MM-DD)'.format(date_str))
    return datetime.date(*map(int, parts))

def split(sequence_str, *, word='and', default=None):
    if default is not None and sequence_str == default:
        return
    match = re.match('([^,]+) {} ([^,]+)'.format(word), sequence_str)
    if match:
        yield match.group(1)
        yield match.group(2)
    assert ', ' in sequence_str
    split_seq = sequence_str.split(', ')
    for i, item in enumerate(split_seq):
        if i == len(split_seq) - 1:
            assert item.startswith(word + ' ')
            yield item[len(word) + 1:]
        else:
            yield item

if __name__ == '__main__':
    print('[....] parsing Comprehensive Rules', end='', flush=True)
    with open('data/MagicCompRules.txt') as comp_rules_f:
        comp_rules = CompRules(comp_rules_f)
    print('\r[ ok ]')
    print('[....] applying Comprehensive Rules patch', end='', flush=True)
    with open('data/rules-patch.json') as rules_patch_f:
        rules_patch = json.load(rules_patch_f)
    comp_rules.apply_patch(rules_patch)
    print('\r[ ok ]')
    print('[....] saving patched Comprehensive Rules', end='', flush=True)
    with open('data/MagicCompRules.txt', 'w') as comp_rules_f:
        comp_rules.dump(comp_rules_f)
    print('\r[ ok ]')
