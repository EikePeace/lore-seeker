#!/usr/bin/env python3

import datetime
import json
import more_itertools
import re
import subprocess

SUBRULE_IDX = 'abcdefghijkmnpqrstuvwxyz'

class CompRules:
    def __init__(self, comp_rules_f):
        self.patches = {}
        self.keyword_actions = {}
        self.keyword_abilities = {}
        lines = more_itertools.peekable(comp_rules_f)
        # title and date
        assert next(lines) == 'Magic: The Gathering Comprehensive Rules\n'
        assert next(lines) == '\n'
        match = re.fullmatch('These rules are effective as of ([A-Za-z]+) ([0-9]+), ([0-9]+).\n', next(lines))
        assert match
        year = int(match.group(3))
        month = [None, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].index(match.group(1))
        day = int(match.group(2))
        self.date = datetime.date(year, month, day)
        assert next(lines) == '\n'
        # header
        self.header = ''
        seen_contents_start = False
        for line in lines:
            if lines.peek() == '1. Game Concepts\n':
                if seen_contents_start:
                    break
                else:
                    seen_contents_start = True
            self.header += line
        # rules
        self.sections = []
        current_section = None
        current_subsection = None
        current_rule = ''
        is_subrule = False
        for line in lines:
            # paragraph break
            if re.fullmatch(' *\n', line):
                if current_rule != '':
                    if is_subrule:
                        current_subsection['rules'][-1]['subrules'].append(current_rule)
                    else:
                        current_subsection['rules'].append({
                            'subrules': [],
                            'text': current_rule
                        })
                if lines.peek() == 'Glossary\n':
                    current_section['subsections'].append(current_subsection)
                    self.sections.append(current_section)
                    break
                current_rule = ''
                continue
            # section header
            match = re.fullmatch('([0-9])\\. (.+)\n', line)
            if match:
                if current_subsection is not None:
                    current_section['subsections'].append(current_subsection)
                if current_section is not None:
                    self.sections.append(current_section)
                assert int(match.group(1)) == len(self.sections) + 1
                current_section = {
                    'name': match.group(2),
                    'subsections': []
                }
                current_subsection = None
                continue
            # subsection header
            match = re.fullmatch('([0-9]{3})\\. (.+)\n', line)
            if match:
                if current_subsection is not None:
                    current_section['subsections'].append(current_subsection)
                assert int(match.group(1)) // 100 == len(self.sections) + 1
                assert int(match.group(1)) % 100 == len(current_section['subsections'])
                current_subsection = {
                    'name': match.group(2),
                    'rules': []
                }
                continue
            # rule text
            if current_rule == '':
                match = re.fullmatch('([0-9]{3})\\.([0-9]+)[a-z]\\.? (.+)\n', line)
                is_subrule = bool(match)
                if is_subrule:
                    assert int(match.group(2)) == len(current_subsection['rules'])
                else:
                    match = re.fullmatch('([0-9]{3})\\.([0-9]+). (.+)\n', line)
                    assert int(match.group(2)) == len(current_subsection['rules']) + 1
                assert int(match.group(1)) // 100 == len(self.sections) + 1
                assert int(match.group(1)) % 100 == len(current_section['subsections'])
                current_rule += match.group(3)
            else:
                current_rule += '\n' + line[:-1]
        # footer
        self.footer = ''
        for line in lines:
            self.footer += line

    def __getitem__(self, key):
        match = re.fullmatch('([0-9]{3})\\.?', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            return subsection
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            return subsection['rules'][int(match.group(2)) - 1]['text']
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)([abcdefghijkmnpqrstuvwxyz])', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            rule = subsection['rules'][int(match.group(2)) - 1]
            return rule['subrules'][SUBRULE_IDX.index(match.group(3))]
        raise KeyError('Could not parse rule number: {!r}'.format(key))

    def __setitem__(self, key, value):
        match = re.fullmatch('([0-9]{3})\\.?', key)
        if match:
            subsection_number = int(match.group(1))
            self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100] = value
            return
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            subsection['rules'][int(match.group(2)) - 1]['text'] = value
            return
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)([abcdefghijkmnpqrstuvwxyz])', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            rule = subsection['rules'][int(match.group(2)) - 1]
            rule['subrules'][SUBRULE_IDX.index(match.group(3))] = value
            return
        raise KeyError('Could not parse rule number: {!r}'.format(key))

    def apply_patch(self, patch_json):
        if parse_iso_date(patch_json['base']) != self.date:
            raise ValueError('This rules patch is for a different version of the rules')
        self.date = datetime.datetime.utcfromtimestamp(int(subprocess.run(['git', 'log', '-n1', '--pretty=format:%ct', '--', 'data/rules-patch.json'], stdout=subprocess.PIPE, universal_newlines=True).stdout)).date()
        for patch in patch_json['patches']:
            if patch['type'] == 'add':
                match = re.fullmatch('([0-9]{3})\\.?', patch['rule'])
                if match:
                    if isinstance(patch['text'], str):
                        rule = {'subrules': [], 'text': patch['text']}
                    else:
                        rule = patch['text']
                    self[patch['rule']]['rules'].append(rule)
                    self.patches['{}.{}'.format(match.group(1), len(self[patch['rule']]['rules']))] = patch['#']
                    continue
                match = re.fullmatch('([0-9]{3})\\.([0-9]+)', patch['rule'])
                if match:
                    rule = self[match.group(1)]['rules'][int(match.group(2)) - 1]
                    rule['subrules'].append(patch['text'])
                    self.patches[patch['rule'] + SUBRULE_IDX[len(rule['subrules']) - 1]] = patch['#']
                    continue
                raise ValueError('Could not parse rule number: {!r}'.format(patch['rule']))
            elif patch['type'] == 'addAbilityWords':
                # patch CR
                match = re.fullmatch('(.*)\\. The ability words are (.+).', self['207.2c'])
                ability_words = set(split(match.group(2)))
                for new_ability_word in patch['abilityWords']:
                    assert new_ability_word not in ability_words
                    ability_words.add(new_ability_word)
                self['207.2c'] = '{}. The ability words are {}.'.format(match.group(1), join(sorted(ability_words)))
                self.patches['207.2c'] = patch['#']
                # patch frontend
                card_rb = ''
                found_ability_word_list = False
                with open('search-engine/lib/card.rb') as card_rb_f:
                    for line in card_rb_f:
                        if line.startswith('  ABILITY_WORD_LIST = ['):
                            if found_ability_word_list:
                                raise RuntimeError('Found two ability word lists in search-engine/lib/card.rb')
                            else:
                                found_ability_word_list = True
                            card_rb += '  ABILITY_WORD_LIST = {!r}\n'.format(sorted(ability_word.capitalize() for ability_word in ability_words))
                        else:
                            card_rb += line
                with open('search-engine/lib/card.rb', 'w') as card_rb_f:
                    card_rb_f.write(card_rb)
            elif patch['type'] == 'addKeywordAbility':
                self['702']['rules'].append(patch['rule'])
                rule_number = '702.{}'.format(len(self['702']['rules']))
                self.patches[rule_number] = patch['#']
                self.keyword_abilities[patch['rule']['text']] = rule_number
            elif patch['type'] == 'addKeywordAction':
                self['701']['rules'].append(patch['rule'])
                '701.{}'.format(len(self['701']['rules']))
                self.patches[rule_number] = patch['#']
                self.keyword_actions[patch['rule']['text']] = rule_number
            elif patch['type'] == 'addSpecialAction':
                numbers = [
                    'zero',
                    'one',
                    'two',
                    'three',
                    'four',
                    'five',
                    'six',
                    'seven',
                    'eight',
                    'nine',
                    'ten',
                    'eleven',
                    'twelve'
                ]
                match = re.fullmatch('There are ([^ ]+) special actions:', self['115.2'])
                try:
                    num_special_actions = int(match.group(1))
                except ValueError:
                    num_special_actions = numbers.index(match.group(1))
                num_special_actions += 1
                self['115.2'] = 'There are {} special actions:'.format(numbers[num_special_actions] if num_special_actions < len(numbers) else num_special_actions)
                self['115']['rules'][1]['subrules'].append(patch['text'])
                self.patches['115.2'] = 'updated the number of special actions'
                self.patches['115.2' + SUBRULE_IDX[len(self['115']['rules'][1]['subrules']) - 1]] = patch['#']
            elif patch['type'] == 'addSubtypes':
                rule = self['205.3']
                subrule_id = {
                    'Artifact': 'g',
                    'Creature': 'm',
                    'Enchantment': 'h',
                    'Land': 'i',
                    'Plane': 'n',
                    'Planeswalker': 'j',
                    'Sorcery': 'k'
                }[patch['cardType']]
                subrule = self['205.3{}'.format(subrule_id)]
                if patch['cardType'] in ('Artifact', 'Enchantment', 'Creature', 'Plane', 'Planeswalker', 'Sorcery'):
                    match = re.fullmatch('(.*)\\. The ([^ ]+) types are (.+).()', subrule)
                elif patch['cardType'] == 'Land':
                    match = re.fullmatch('(.*)\\. The ([^ ]+) types are (.+).(\n[^\n]*)', subrule)
                else:
                    raise NotImplementedError('Unknown card type: {!r}'.format(patch['cardType']))
                subtypes = {re.sub(' \\(.+\\)', '', subtype): subtype for subtype in split(match.group(3))}
                for new_subtype in patch['subtypes']:
                    if new_subtype not in subtypes:
                        subtypes[new_subtype] = new_subtype
                self['205.3{}'.format(subrule_id)] = '{}. The {} types are {}.{}'.format(match.group(1), match.group(2), join(v for k, v in sorted(subtypes.items())), match.group(4))
                self.patches['205.3{}'.format(subrule_id)] = patch['#']
            elif patch['type'] == 'append':
                self[patch['rule']] += ' ' + patch['text']
                self.patches[patch['rule']] = patch['#']
            elif patch['type'] == 'insert':
                self.insert(patch['rule'], patch['text'])
                self.patches[patch['rule']] = patch['#']
            elif patch['type'] == 'insertText':
                left, right = self[patch['rule']].split(patch['after'], 2)
                self[patch['rule']] = left + patch['after'] + patch['text'] + right
                self.patches[patch['rule']] = patch['#']
            elif patch['type'] == 'replace':
                self[patch['rule']] = re.sub(patch['find'], patch['replace'], self[patch['rule']])
                self.patches[patch['rule']] = patch['#']
            elif patch['type'] == 'replaceRule':
                self[patch['rule']] = patch['text']
                self.patches[patch['rule']] = patch['#']
            else:
                raise NotImplementedError('Unknown patch type: {!r}'.format(patch['type']))

    def dump(self, comp_rules_f):
        # title and date
        comp_rules_f.write('Custom Magic Comprehensive Rules\n')
        comp_rules_f.write('\n')
        comp_rules_f.write('These rules are effective as of {0:%B} {1}, {0:%Y}.\n'.format(self.date, self.date.day))
        comp_rules_f.write('\n')
        # header
        header = '\n'.join(self.header.split('\n')[:-4])
        intro, contents = header.split('Contents', 1)
        header = ''.join([
            'Introduction\n\n This document contains a series of house rules for playing the Custom Constructed formats. For ease of reading, they are presented within the context of the Comprehensive Rules which they are patching.\n\nThe following rules have been patched:\n\n',
            '\n'.join('{}: {}'.format(rule, patch) for rule, patch in sorted(self.patches.items(), key=lambda kv: rule_sort_key(kv[0]))),
            '\n\nThese are not the official Magic rules, you can find those at ',
            intro.split(' ')[-1],
            'Contents',
            contents
        ])
        comp_rules_f.write(header)
        # rules
        for i, section in enumerate(self.sections):
            section_number = i + 1
            comp_rules_f.write('\n')
            comp_rules_f.write('{}. {}\n'.format(section_number, section['name']))
            for j, subsection in enumerate(section['subsections']):
                subsection_number = 100 * section_number + j
                comp_rules_f.write('\n')
                comp_rules_f.write('{}. {}\n'.format(subsection_number, subsection['name']))
                for k, rule in enumerate(subsection['rules']):
                    rule_number = k + 1
                    comp_rules_f.write('\n')
                    comp_rules_f.write('{}.{}. {}\n'.format(subsection_number, rule_number, self.process_references(rule['text'])))
                    for l, subrule in enumerate(rule['subrules']):
                        subrule_number = SUBRULE_IDX[l]
                        comp_rules_f.write('\n')
                        comp_rules_f.write('{}.{}{} {}\n'.format(subsection_number, rule_number, subrule_number, self.process_references(subrule)))
        # footer
        #comp_rules_f.write(self.footer)

    def insert(self, key, value):
        match = re.fullmatch('([0-9]{3})\\.?', key)
        if match:
            subsection_number = int(match.group(1))
            self.sections[subsection_number // 100 - 1]['subsections'].insert(subsection_number % 100, value)
            return
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            if isinstance(value, str):
                value = {'subrules': [], 'text': value}
            subsection['rules'].insert(int(match.group(2)) - 1, value)
            return
        match = re.fullmatch('([0-9]{3})\\.([0-9]+)([abcdefghijkmnpqrstuvwxyz])', key)
        if match:
            subsection_number = int(match.group(1))
            subsection = self.sections[subsection_number // 100 - 1]['subsections'][subsection_number % 100]
            rule = subsection['rules'][int(match.group(2)) - 1]
            rule['subrules'].insert(SUBRULE_IDX.index(match.group(3)), value)
            return
        raise KeyError('Could not parse rule number: {!r}'.format(key))

    def process_references(self, text):
        for keyword_action, rule_number in self.keyword_actions:
            text = text.replace('{{keywordAction:{}}}'.format(keyword_action), rule_number)
        for keyword_ability, rule_number in self.keyword_abilities:
            text = text.replace('{{keywordAbility:{}}}'.format(keyword_ability), rule_number)
        return text

def join(sequence, *, word='and', default=None):
    sequence = [str(elt) for elt in sequence]
    if len(sequence) == 0:
        if default is None:
            raise IndexError('Tried to join empty sequence with no default')
        else:
            return str(default)
    elif len(sequence) == 1:
        return sequence[0]
    elif len(sequence) == 2:
        return '{} {} {}'.format(sequence[0], word, sequence[1])
    else:
        return ', '.join(sequence[:-1]) + ', {} {}'.format(word, sequence[-1])

def parse_iso_date(date_str):
    if isinstance(date_str, datetime.date):
        return date_str
    parts = date_str.split('-')
    if len(parts) != 3:
        raise ValueError('Failed to parse date from {!r} (format should be YYYY-MM-DD)'.format(date_str))
    return datetime.date(*map(int, parts))

def split(sequence_str, *, word='and', default=None):
    if default is not None and sequence_str == default:
        return
    match = re.match('([^,]+) {} ([^,]+)'.format(word), sequence_str)
    if match:
        yield match.group(1)
        yield match.group(2)
    assert ', ' in sequence_str
    split_seq = sequence_str.split(', ')
    for i, item in enumerate(split_seq):
        if i == len(split_seq) - 1:
            assert item.startswith(word + ' ')
            yield item[len(word) + 1:]
        else:
            yield item

def rule_sort_key(key):
    match = re.fullmatch('([0-9]{3})\\.?', key)
    if match:
        return int(match.group(1)), None, None
    match = re.fullmatch('([0-9]{3})\\.([0-9]+)', key)
    if match:
        return int(match.group(1)), int(match.group(2))
    match = re.fullmatch('([0-9]{3})\\.([0-9]+)([abcdefghijkmnpqrstuvwxyz])', key)
    if match:
        return int(match.group(1)), int(match.group(2)), match.group(3)
    raise KeyError('Could not parse rule number: {!r}'.format(key))

if __name__ == '__main__':
    print('[....] parsing Comprehensive Rules', end='', flush=True)
    with open('data/MagicCompRules.txt') as comp_rules_f:
        comp_rules = CompRules(comp_rules_f)
    print('\r[ ok ]')
    print('[....] applying Comprehensive Rules patch', end='', flush=True)
    with open('data/rules-patch.json') as rules_patch_f:
        rules_patch = json.load(rules_patch_f)
    comp_rules.apply_patch(rules_patch)
    print('\r[ ok ]')
    print('[....] saving patched Comprehensive Rules', end='', flush=True)
    with open('data/MagicCompRules.txt', 'w') as comp_rules_f:
        comp_rules.dump(comp_rules_f)
    print('\r[ ok ]')
