#!/usr/bin/env python3

import sys

sys.path.append('/opt/py')

import collections
import copy
import io
import itertools
import json
import os
import pathlib
import platform
import re
import subprocess
import tempfile
import zipfile

import PIL.Image # PyPI: Pillow
import more_itertools # PyPI: more-itertools

import gitdir.host.github # https://github.com/fenhl/gitdir
import lazyjson # https://github.com/fenhl/lazyjson
import mse_to_json # https://github.com/fenhl/mse-to-json

BASE_PATH = pathlib.Path(os.environ.get('LORESEEKERDATA', '/usr/local/share/fenhl/lore-seeker'))
CACHE = {'set_files': {}}
STAGE = gitdir.host.github.GitHub().repo('fenhl/lore-seeker').stage_path
CACHING_FLAG = STAGE / 'frontend' / 'tmp' / 'caching-dev.txt'
CUSTOM_SETS = STAGE / 'data' / 'sets'
REMOTE_STAGE = pathlib.Path('/opt/git/github.com/fenhl/lore-seeker/stage')
SUBCOMMANDS = {}

PRINTING_SPECIFIC_FIELDS = {
    'artist',
    'borderColor',
    'duelDeck',
    'flavorText',
    'foreignData',
    'frameVersion',
    'hasFoil',
    'hasNonFoil',
    'isArena',
    'isFullArt',
    'isMtgo',
    'isOnlineOnly',
    'isOversized',
    'isPaper',
    'isPromo',
    'isReprint',
    'isStarter',
    'isStorySpotlight',
    'isTextless',
    'isTimeshifted',
    'legalities', # recalculated by Lore Seeker
    'mcmId',
    'mcmMetaId',
    'mtgArenaId',
    'mtgoFoilId',
    'mtgoId',
    'mtgstocksId',
    'multiverseId',
    'number',
    'originalName',
    'originalText',
    'originalType',
    'purchaseUrls',
    'rarity',
    'rulings', # migrated differently
    'scryfallId',
    'scryfallIllustrationId',
    'scryfallOracleId',
    'tcgplayerProductId',
    'tcgplayerPurchaseUrl',
    'uuid',
    'variations',
    'watermark'
}

SIMPLE_FIELDS = [
    'artist',
    'borderColor',
    'colorIdentity',
    'colorIndicator',
    'colors',
    'convertedManaCost', #TODO recalculate from card['manaCost']?
    'faceConvertedManaCost', #TODO recalculate from card['manaCost']?
    'frameVersion',
    'hasFoil',
    'hasNonFoil',
    'layout',
    'loyalty',
    'manaCost',
    'power',
    'rarity',
    'side',
    'stability',
    'subtypes',
    'supertypes',
    'text',
    'toughness',
    'type', #TODO recalculate from supertypes/types/subtypes?
    'types',
    'watermark'
]

def subcommand(f, name=None):
    if isinstance(f, str):
        return lambda f_inner: subcommand(f_inner, name=f)
    if name is None:
        name = f.__name__
    SUBCOMMANDS[name] = f
    return f

def build_name_map(ver_dir, old, new):
    if 'cards' in old:
        rename_path = ver_dir / 'name-changes.txt'
        if rename_path.exists():
            input(f'[ ?? ] using existing card name mapping {rename_path} [you may edit it now, then press return to continue]')
        else:
            with rename_path.open('w', encoding='utf-8') as f:
                print('# name mapping between old version with errata and new version with errata', file=f)
                #TODO print FROM line
                for new_card in new['cards']:
                    if not any(old_card['name'] == new_card['name'] for old_card in old['cards']):
                        print(f'=> {new_card["name"]}', file=f)
                for old_card in old['cards']:
                    if not any(old_card['name'] == new_card['name'] for new_card in new['cards']):
                        print(f'{old_card["name"]} =>', file=f)
                for new_card in new['cards']:
                    if any(old_card['name'] == new_card['name'] for old_card in old['cards']):
                        print(f'{new_card["name"]} => {new_card["name"]}', file=f)
            input(f'[ ?? ] created new card name mapping {rename_path} [you may edit it now, then press return to continue]')
        with rename_path.open(encoding='utf-8') as f:
            name_map_doc = f.read()
        name_map = {} # map new name with errata to (old name, new name without errata)
        for i, line in enumerate(name_map_doc.splitlines()):
            if not line.strip():
                continue
            if line.strip().startswith('#'):
                continue
            match = re.fullmatch(' *FROM +([^ ]+) *', line)
            if match:
                continue #TODO check to make sure the previous version matches, if not, also check that version's name-changes.txt
            match = re.fullmatch(' *([^=]+?) *=> *([^=]+?) *=> *([^=]+?) *', line)
            if match:
                name_map[match.group(3)] = match.group(1), match.group(2)
                continue
            match = re.fullmatch(' *=> *([^=]+?) *', line)
            if match:
                name_map[match.group(1)] = None, None
                continue
            match = re.fullmatch(' *([^=]+?) *=> *', line)
            if match:
                continue # removed cards currently unused
            match = re.fullmatch(' *([^=]+?) *=> *([^=]+?) *', line)
            if match:
                name_map[match.group(2)] = match.group(1), match.group(2)
                continue
            raise ValueError(f'Failed to parse line {i + 1} in name map: {line!r}')
        for new_card in new['cards']:
            if new_card['name'] not in name_map:
                print(f'[ !! ] {new_card["name"]} missing from name map, assuming unchanged')
                name_map[new_card['name']] = new_card['name'], new_card['name']
    else:
        name_map = {card['name']: (None, card['name']) for card in new['cards']}
    return name_map

def card_diff(set_code, card_name, old_card, new_card, errata_card=None):
    if errata_card is None:
        def card_diff_field(field_name):
            if field_name not in old_card and field_name in new_card:
                return 'added: {}: {}'.format(json.dumps(field_name), '    \n'.join(line for line in json.dumps(new_card[field_name]).split('\n')))
            elif field_name in old_card and field_name not in new_card:
                return 'removed: {}: {}'.format(json.dumps(field_name), '    \n'.join(line for line in json.dumps(old_card[field_name]).split('\n')))
            elif old_card[field_name] != new_card[field_name]:
                return 'old: {0}: {1}\n    new: {0}: {1}'.format(
                    json.dumps(field_name),
                    '    \n'.join(line for line in json.dumps(old_card[field_name]).split('\n')),
                    '    \n'.join(line for line in json.dumps(new_card[field_name]).split('\n'))
                )
            else:
                return None
    else:
        def card_diff_field(field_name):
            if field_name in new_card and field_name in errata_card and (field_name not in old_card or old_card[field_name] != new_card[field_name] == errata_card[field_name]):
                return '# old: {}\n    # new: {}\n    {}: {}'.format(
                    '    \n'.join(line for line in json.dumps(old_card[field_name]).split('\n')) if field_name in old_card else 'missing',
                    '    \n'.join(line for line in json.dumps(new_card[field_name]).split('\n')),
                    json.dumps(field_name),
                    '    \n'.join(line for line in json.dumps(errata_card[field_name]).split('\n'))
                )
            elif field_name in old_card and field_name not in new_card and field_name not in errata_card:
                return '# {} removed, was {}'.format(json.dumps(field_name), '    \n'.join(line for line in json.dumps(old_card[field_name]).split('\n')))
            else:
                return '{}: {}'.format(json.dumps(field_name), '    \n'.join(line for line in json.dumps(errata_card[field_name]).split('\n')))

    return f'# {card_name} ({set_code})\n{{\n    ' + ',\n    '.join(
        card_diff_field(field_name)
        for field_name in SIMPLE_FIELDS
        if field_name in old_card or field_name in (new_card if errata_card is None else errata_card)
        and card_diff_field(field_name) is not None
    ) + '\n}'

def choose(question, choices):
    answer = input(f'[ ?? ] {question} [{"/".join(choice[0] for choice in choices)}] ')
    while True:
        for choice in choices:
            if answer.lower() in {choice[0], choice}:
                return choice
        answer = input('[ ?? ] unrecognized answer, type {}: '.format(join((f'“{choice}”' for choice in choices), word='or')))

@subcommand
def debug(*args):
    if '--cache' in args:
        if not CACHING_FLAG.exists():
            with CACHING_FLAG.open('w', encoding='utf-8'):
                pass # write empty file
    else:
        if CACHING_FLAG.exists():
            CACHING_FLAG.unlink()
    with (BASE_PATH / 'config.json').open(encoding='utf-8') as config_f:
        config = json.load(config_f)
    env = {
        'DISCORD_CLIENT_ID': config['clientID'],
        'DISCORD_CLIENT_SECRET': config['clientSecret'],
        **os.environ
    }
    was_running = subprocess.run(['systemctl', 'is-active', '--quiet', 'lore-seeker-dev']).returncode == 0
    if was_running:
        subprocess.run(['sudo', 'systemctl', 'stop', 'lore-seeker-dev'], check=True)
    try:
        exit_code = subprocess.run(['bundle', 'exec', 'rails', 'server', '-p', '18808'], env=env, cwd=STAGE / 'frontend').returncode
    except KeyboardInterrupt:
        exit_code = 0
    if was_running:
        subprocess.run(['sudo', 'systemctl', 'start', 'lore-seeker-dev'], check=True)
    return exit_code

@subcommand
def diff(set_code, old_version, new_version):
    set_dir = pathlib.Path.home() / 'games' / 'magic' / 'set' / set_code.lower()
    if not set_dir.exists():
        raise FileNotFoundError(f'No such set directory: {set_dir}')
    old_ver_dir = set_dir / f'v{old_version}'
    if (old_ver_dir / 'errata.mse-set').exists():
        with zipfile.ZipFile(old_ver_dir / 'errata.mse-set') as set_file:
            old_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=old_version)
    else:
        with zipfile.ZipFile(old_ver_dir / 'set.mse-set') as set_file:
            old_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=old_version)
    new_ver_dir = set_dir / f'v{new_version}'
    if (new_ver_dir / 'errata.mse-set').exists():
        with zipfile.ZipFile(new_ver_dir / 'errata.mse-set') as set_file:
            new_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=new_version)
    else:
        with zipfile.ZipFile(new_ver_dir / 'set.mse-set') as set_file:
            new_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=new_version)
    print(diff_set_jsons(new_ver_dir, old_set_json, new_set_json))

def diff_set_jsons(new_ver_dir, old, new):
    name_map = build_name_map(new_ver_dir, old, new)
    set_json['cards'] = []
    for old_card in old.get('cards', []):
        if not any(old_card['name'] == name_map[new_card['name']][0] for new_card in new['cards']):
            yield f'# {old_card["name"]}: card removed'
    for new_card in new['cards']:
        for old_card in old.get('cards', []):
            if old_card['name'] == name_map[new_card['name']][0]:
                break
        else:
            yield f'# {new_card["name"]}: card added'
            continue
        reprint_card, card_name, card = merge_card_fields(reprint_card, old_card, new_card, errata_card, None if reprint_card is None else reprint_set['code'], set_json['code'])
        card['name'] = card_name
        set_json['cards'].append(card)
    return set_json

def edit(original):
    with tempfile.NamedTemporaryFile('w', delete=False) as f:
        f.write(original)
        tmp = pathlib.Path(f.name)
    if platform.system() == 'Windows':
        subprocess.run([str(pathlib.Path.home() / 'AppData' / 'Local' / 'atom' / 'bin' / 'atom.cmd'), '--wait', str(tmp)], check=True)
    else:
        subprocess.run(['nano', str(tmp)], check=True)
    with tmp.open(encoding='utf-8') as f:
        edited = f.read()
    tmp.unlink()
    return edited

def edit_rulings(card_name, old_rulings):
    edited_rulings = edit(f'# rulings for {card_name}\n' + '\n'.join(f'{ruling["date"]} {ruling["text"]}' for ruling in old_rulings))
    return [
        {'date': line[:len('YYYY-mm-dd')], 'text': line[len('YYYY-mm-dd '):]}
        for line in edited_rulings.splitlines()
        if not line.strip().startswith('#')
    ]

def get_cached_set_file(set_path):
    set_path = set_path.resolve()
    if set_path not in CACHE['set_files']:
        with set_path.open(encoding='utf-8') as set_f:
            CACHE['set_files'][set_path] = json.load(set_f)
    return CACHE['set_files'][set_path]

def img_dirs(set_info, version):
    set_name = set_info['name']
    set_dir = pathlib.Path.home() / 'games' / 'magic' / 'set' / set_info['code'].lower()
    card_count = collections.defaultdict(lambda: 0)
    # check if new-style Cockatrice export exists and use only that if it does
    errata_img_dir = set_dir / f'v{version}' / 'trice-errata'
    original_img_dir = set_dir / f'v{version}' / 'trice'
    if errata_img_dir.exists() and original_img_dir.exists():
        if os.environ.get('LSIMG_ERRATA', 'yes') == 'yes':
            errata = True
        elif os.environ.get('LSIMG_ERRATA', 'yes') == 'no':
            errata = False
        else:
            errata = yesno(f"use errata'd images for {set_info['code']}?")
        if errata:
            return [errata_img_dir]
        else:
            return [original_img_dir]
    elif not (errata_img_dir.exists() or original_img_dir.exists()):
        pass # new-style Cockatrice export doesn't exist, use old-style source dir
    else:
        return [more_itertools.one(dir for dir in [errata_img_dir, original_img_dir] if dir.exists())]
    # determine old-style source dir
    errata_img_dir = set_dir / f'v{version}' / 'img-errata'
    original_img_dir = set_dir / f'v{version}' / 'img'
    if errata_img_dir.exists() and original_img_dir.exists():
        if os.environ.get('LSIMG_ERRATA', 'yes') == 'yes':
            errata = True
        elif os.environ.get('LSIMG_ERRATA', 'yes') == 'no':
            errata = False
        else:
            errata = yesno(f"use errata'd images for {set_info['code']}?")
        if errata:
            return [errata_img_dir, original_img_dir]
        else:
            return [original_img_dir, errata_img_dir]
    elif not (errata_img_dir.exists() or original_img_dir.exists()):
        raise FileNotFoundError(f'no images directory found for {set_info["code"]} version {version}')
    else:
        return [more_itertools.one(dir for dir in [errata_img_dir, original_img_dir] if dir.exists())]

def img_filename(card_name, set_img_dirs, count=0, *, original_name=None):
    # generate all possible variants of the filename
    transformations = [
        lambda filename: ([
            filename,
            filename.split(':', 1)[1],
            filename.replace(':', '')
        ] if ':' in filename else [filename]),
        lambda filename: [
            filename,
            filename.replace("'", '').replace('‘', '').replace('’', ''),
            filename.replace("'", '’'),
            filename.replace("'", '_')
        ],
        lambda filename: [
            filename,
            filename.replace(',', ''),
            filename.replace(',', '_')
        ],
        lambda filename: ([f'{filename}.{count}', filename] if count > 0 else [filename]),
        lambda filename: [f'{filename}.full', filename],
        lambda filename: [f'{filename}.png', f'{filename}.jpg']
    ]
    if original_name is None:
        filenames = [card_name]
    else:
        filenames = [card_name, original_name]
    for transformation in transformations:
        filenames = list(more_itertools.flatten(map(transformation, filenames)))
    paths = [img_dir / filename for img_dir in set_img_dirs for filename in filenames]
    # check variants for existing files in order
    for path in paths:
        if path.exists():
            if path.suffix == '.jpg':
                new_path = path.parent / f'{path.stem}.png'
                subprocess.run(['convert', str(path), str(new_path)], check=True)
                path.unlink()
                path = new_path
            return path
    raise ValueError(f'Image file for {card_name} not found in {set_img_dirs}')

@subcommand('import')
def import_set(set_code, set_version):
    gefolge_conf = lazyjson.SFTPFile('mercredi.fenhl.net', 22, '/usr/local/share/fidera/games/magic.json', username='fenhl')
    if set_code not in gefolge_conf['customSets']:
        gefolge_conf['customSets'][set_code] = {}
    if 'blurb' not in gefolge_conf['customSets'][set_code]:
        gefolge_conf['customSets'][set_code]['blurb'] = input(f'Beschreibung für gefolge.org: {set_code} ')
    set_dir = pathlib.Path.home() / 'games' / 'magic' / 'set' / set_code.lower()
    if not set_dir.exists():
        raise FileNotFoundError(f'No such set directory: {set_dir}')
    ver_dir = set_dir / f'v{set_version}'
    if (ver_dir / 'errata.mse-set').exists() and (ver_dir / 'set.mse-set').exists():
        with zipfile.ZipFile(ver_dir / 'errata.mse-set') as set_file:
            errata_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=set_version)
        with zipfile.ZipFile(ver_dir / 'set.mse-set') as set_file:
            new_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=set_version)
    elif (ver_dir / 'errata.mse-set').exists():
        with zipfile.ZipFile(ver_dir / 'errata.mse-set') as set_file:
            new_set_json = errata_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=set_version)
    else:
        with zipfile.ZipFile(ver_dir / 'set.mse-set') as set_file:
            new_set_json = errata_set_json = mse_to_json.convert_mse_set(set_file, set_code=set_code, version=set_version)
    set_json_path = pathlib.Path(f'data/sets/{set_code}.json')
    if set_json_path.exists():
        with set_json_path.open(encoding='utf-8') as set_file:
            old_set_json = json.load(set_file)
    else:
        old_set_json = {}
    set_json = merge_set_jsons(set_json_path, ver_dir, old=old_set_json, new=new_set_json, errata=errata_set_json)
    with set_json_path.open('w', encoding='utf-8') as set_file:
        json.dump(set_json, set_file, indent=4, sort_keys=True)
        print(file=set_file)

def input_default(question, default, convert=lambda x: x):
    result = input(f'[ ?? ] {question} [{default}]: ').strip()
    if result == '':
        return default
    return convert(result)

def join(words, default=None, word='and'):
    words = list(words)
    if len(words) == 0:
        return default
    elif len(words) == 1:
        return words[0]
    elif len(words) == 2:
        return f'{words[0]} {word} {words[1]}'
    else:
        return ', '.join(words[:-1]) + f', {word} {words[-1]}'

def merge_card_fields(reprint_card, old_card, new_card, errata_card, reprint_set_code, set_code):
    card_name = errata_card['name']
    if reprint_card is not None and any(
        not reprint_eq(field_name, reprint_card.get(field_name), errata_card.get(field_name))
        for field_name in set(reprint_card).union(errata_card) - PRINTING_SPECIFIC_FIELDS
    ):
        print(f'[ ** ] {reprint_set_code}/{set_code} reprint changes for {card_name}')
        for field_name in sorted(set(reprint_card).union(errata_card) - PRINTING_SPECIFIC_FIELDS):
            if field_name not in reprint_card and field_name in errata_card:
                print(f'[ ** ] new {field_name}: {json.dumps(errata_card.get(field_name))}')
            elif field_name in reprint_card and field_name not in errata_card:
                print(f'[ ** ] {field_name} removed, was {json.dumps(reprint_card.get(field_name))}')
            elif not reprint_eq(field_name, reprint_card.get(field_name), errata_card.get(field_name)):
                print(f'[ ** ] {field_name}:')
                print(f'[{reprint_set_code}{":" if len(reprint_set_code) < 4 else ""}] {json.dumps(reprint_card.get(field_name))}')
                print(f'[{set_code}{":" if len(set_code) < 4 else ""}] {json.dumps(errata_card.get(field_name))}')
        if yesno('some fields differ in reprint, prefix card name with set code?'):
            card_name = f'{set_code}:{card_name}'
            reprint_card = None
    if reprint_card is None and old_card is None:
        # always review new cards
        json_card = json.dumps({
            field_name: field_value
            for field_name, field_value in errata_card.items()
            if field_name in SIMPLE_FIELDS
        }, indent=4, sort_keys=True)
        edited = edit(f'# {card_name} ({set_code}, new card)\n{json_card}')
        return reprint_card, card_name, json.loads('\n'.join(
            line
            for line in edited.splitlines()
            if not line.strip().startswith('#')
        ))
    elif old_card is not None and new_card is not None and any(
        ((field_name in old_card) != (field_name in new_card) and (field_name in new_card) == (field_name in errata_card))
        or old_card.get(field_name) != new_card.get(field_name) == errata_card.get(field_name)
        for field_name in SIMPLE_FIELDS
    ):
        print(f'[ ** ] changes for {card_name}')
        for field_name in SIMPLE_FIELDS:
            if field_name not in old_card and field_name in new_card and field_name in errata_card and new_card[field_name] == errata_card[field_name]:
                print(f'[ ** ] new {field_name}: {json.dumps(new_card.get(field_name))}')
            elif field_name in old_card and field_name not in new_card and field_name not in errata_card:
                print(f'[ ** ] {field_name} removed, was {json.dumps(old_card.get(field_name))}')
            elif old_card.get(field_name) != new_card.get(field_name) == errata_card.get(field_name):
                print(f'[ ** ] {field_name}:')
                print(f'[old:] {json.dumps(old_card.get(field_name))}')
                print(f'[new:] {json.dumps(new_card.get(field_name))}')
        choice = choose('use fields from [o]ld card, from [n]ew card with errata, or [e]dit manually?', ['old', 'new', 'edit'])
        if choice == 'old':
            return reprint_card, card_name, {
                field_name: old_card[field_name]
                for field_name in SIMPLE_FIELDS
                if field_name in old_card
            }
        elif choice == 'new':
            return reprint_card, card_name, {
                field_name: errata_card[field_name]
                for field_name in SIMPLE_FIELDS
                if field_name in errata_card
            }
        else:
            return reprint_card, card_name, json.loads('\n'.join(
                line
                for line in edit(card_diff(set_code, card_name, old_card, new_card, errata_card)).splitlines()
                if not line.strip().startswith('#')
            ))
    else:
        return reprint_card, card_name, {
            field_name: errata_card[field_name]
            for field_name in SIMPLE_FIELDS
            if field_name in errata_card
        }

def merge_set_jsons(set_json_path, ver_dir, *, old, new, errata):
    set_json = copy.deepcopy(errata)
    if 'boosterV3' not in set_json:
        if 'boosterV3' in old:
            set_json['boosterV3'] = old['boosterV3']
        else:
            set_json['boosterV3'] = input_default('boosterV3', ['common'] * 10 + ['uncommon'] * 3 + [['rare', 'mythic rare']], convert=json.loads)
    # build rename map
    name_map = build_name_map(ver_dir, old, errata)
    set_json['cards'] = []
    for errata_card in errata['cards']:
        # if this is a reprint, find another printing
        reprint_card, reprint_set = max([
            (reprint_card, get_cached_set_file(iter_set_path))
            for iter_set_path in pathlib.Path('data/sets').iterdir()
            if iter_set_path.resolve() != set_json_path.resolve()
            for i, reprint_card in enumerate(get_cached_set_file(iter_set_path)['cards'])
            if reprint_card['name'] == errata_card['name']
        ], key=lambda tup: (
            not tup[1].get('custom', False), # prefer official sets
            tup[1]['meta']['date'] # prefer newer MTG JSON compilation dates
        ), default=(None, None))
        if reprint_card is not None and reprint_set.get('custom', False):
            print(f'[ ** ] reprint from {reprint_set["code"]}: {reprint_card["name"]}')
        for old_card in old.get('cards', []):
            if old_card['name'] == name_map[errata_card['name']][0]:
                break
        else:
            old_card = None
        if name_map[errata_card['name']][1] is None:
            if old_card is not None and 'originalName' in old_card:
                original_name = old_card['originalName']
            else:
                original_name = errata_card['name']
        else:
            original_name = name_map[errata_card['name']][1]
        try:
            new_card = next(card for card in new['cards'] if card['name'] == original_name)
        except StopIteration as e:
            print(f'[ !! ] No card named {original_name} (original name of {errata_card["name"]}) found in new set without errata')
            new_card = None
        reprint_card, card_name, card = merge_card_fields(reprint_card, old_card, new_card, errata_card, None if reprint_card is None else reprint_set['code'], set_json['code'])
        if 'flavorText' in errata_card:
            card['flavorText'] = errata_card['flavorText']
        card['name'] = card_name
        if 'names' in errata_card:
            card['names'] = errata_card['names'] #TODO make sure any changes to any card's name from merge_card_fields are reflected here
        card['number'] = errata_card['number']
        if new_card is not None:
            card['originalName'] = new_card['name']
            if new_card.get('text', ''):
                card['originalText'] = new_card['text']
            card['originalType'] = new_card['type']
        if reprint_card is None:
            if old_card is None:
                card['rulings'] = edit_rulings(card_name, [])
            elif all((k in old_card) == (k in card) and old_card.get(k) == card.get(k) for k in set(SIMPLE_FIELDS) - PRINTING_SPECIFIC_FIELDS):
                card['rulings'] = old_card.get('rulings', [])
            else:
                card['rulings'] = edit_rulings(card_name, old_card.get('rulings', []))
        else:
            if old_card is None:
                card['rulings'] = reprint_card['rulings']
            else:
                card['rulings'] = sorted(reprint_card['rulings'] + [ruling for ruling in old_card['rulings'] if ruling not in reprint_card['rulings']], key=lambda ruling: ruling['date'])
        set_json['cards'].append(card)
    if 'releaseDate' not in set_json:
        if 'releaseDate' in old:
            set_json['releaseDate'] = old['releaseDate']
        else:
            set_json['releaseDate'] = input('[ ?? ] release date [YYYY-MM-DD]: ')
    if 'type' not in set_json:
        if 'type' in old:
            set_json['type'] = old['type']
        else:
            set_json['type'] = 'core' if yesno('is core set?') else 'expansion'
    return set_json

def reprint_eq(field_name, old_field, new_field):
    def normalized_rules_text(text):
        #text = text.replace('\u2212', '-') # replace Unicode minus used in Oracle text with ASCII hyphen-minus used in MSE
        text = re.sub(' ?\\(.*?\\)', '', text) # remove reminder text #TODO disable this normalization if the old card is from a custom set
        return text

    if old_field == new_field:
        return True
    if field_name == 'names' and not old_field and not new_field:
        return True # missing field same as empty list
    if (old_field is None) != (new_field is None):
        return False
    #if isinstance(old_field, str) and new_field == old_field.replace('\u2212', '-'):
    #    return True
    if field_name in {'colors', 'colorIdentity', 'colorIndicator'} and set(old_field) == set(new_field):
        return True # only order of colors changed
    if field_name == 'text' and normalized_rules_text(old_field) == normalized_rules_text(new_field):
        return True # only reminder text changed
    return False

#TODO add options for --errata, --no-errata, --delete (delete all existing images for sets that will be uploaded before starting)
@subcommand('img')
def upload_images(set_code=None, version=None):
    """Upload custom card images to Lore Seeker."""
    # determine sets and versions
    if set_code is None:
        set_infos = {path.stem: lazyjson.File(path) for path in CUSTOM_SETS.iterdir() if lazyjson.File(path).get('custom', False)}
    elif set_code.endswith('..'):
        set_infos = {path.stem: lazyjson.File(path) for path in CUSTOM_SETS.iterdir() if lazyjson.File(path).get('custom', False) and path.stem >= set_code[:-2]}
    else:
        set_infos = {set_code_part: lazyjson.File(CUSTOM_SETS / f'{set_code_part}.json') for set_code_part in set_code.split(',')}
    if version is None:
        versions = {}
    else:
        versions = {set_code_part: version_part for set_code_part, version_part in itertools.zip_longest(set_code.split(','), version.split(','))}
    for set_code, set_info in sorted(set_infos.items()):
        if versions.get(set_code) is None:
            if 'setVersion' in set_info.get('meta', {}):
                versions[set_code] = set_info['meta']['setVersion'].value()
            elif 'version' in set_info:
                versions[set_code] = set_info['version'].value()
            else:
                version = input(f'[ ?? ] {set_info["name"]} version [leave blank to skip {set_code}]: ')
                if version != '':
                    versions[set_code] = version
    img_dirs_map = {set_code: img_dirs(set_infos[set_code].value(), version) for set_code, version in sorted(versions.items()) if version is not None}
    # upload artwork
    for set_code, version in sorted(versions.items()):
        if version is None:
            continue
        set_info = set_infos[set_code].value()
        set_name = set_info['name']
        set_dir = pathlib.Path.home() / 'games' / 'magic' / 'set' / set_code.lower()
        print(f'[ ** ] uploading artwork for {set_name} version {version}')
        # determine set file
        if (set_dir / f'v{version}' / 'errata.mse-set').exists():
            set_file_path = set_dir / f'v{version}' / 'errata.mse-set'
        else:
            set_file_path = set_dir / f'v{version}' / 'set.mse-set'
        with zipfile.ZipFile(set_file_path) as set_file:
            # make sure target dir exists and is empty
            subprocess.run(['ssh', os.environ.get('LORE_SEEKER_HOSTNAME', 'laire'), 'rm', '-rf', str(REMOTE_STAGE / 'frontend' / 'public' / 'art' / set_code.lower())])
            subprocess.run(['ssh', os.environ.get('LORE_SEEKER_HOSTNAME', 'laire'), 'mkdir', '-p', str(REMOTE_STAGE / 'frontend' / 'public' / 'art' / set_code.lower())], check=True)
            # extract and upload the images
            with tempfile.TemporaryDirectory() as tmp_dir:
                tmp_dir = pathlib.Path(tmp_dir)
                mse_to_json.extract_images(set_file, tmp_dir, set_code=set_code, version=version)
                for img_file in tmp_dir.iterdir():
                    subprocess.run(['scp', str(img_file), f'{os.environ.get("LORE_SEEKER_HOSTNAME", "laire")}:{REMOTE_STAGE / "frontend" / "public" / "art" / set_code.lower() / img_file.name}'], check=True)
    # upload full renders
    for set_code, version in sorted(versions.items()):
        if version is None:
            continue
        set_info = set_infos[set_code].value()
        set_name = set_info['name']
        set_dir = pathlib.Path.home() / 'games' / 'magic' / 'set' / set_code.lower()
        print(f'[ ** ] uploading full renders for {set_name} version {version}')
        card_count = collections.defaultdict(lambda: 0)
        # make sure target dir exists and is empty
        subprocess.run(['ssh', os.environ.get('LORE_SEEKER_HOSTNAME', 'laire'), 'rm', '-rf', str(REMOTE_STAGE / 'frontend' / 'public' / 'cards' / set_code.lower())])
        subprocess.run(['ssh', os.environ.get('LORE_SEEKER_HOSTNAME', 'laire'), 'mkdir', '-p', str(REMOTE_STAGE / 'frontend' / 'public' / 'cards' / set_code.lower())], check=True)
        # determine source dir
        set_img_dirs = img_dirs_map[set_code]
        if len(set_img_dirs) == 1 and set_img_dirs[0].name.startswith('trice'):
            raise NotImplementedError() #TODO
        else:
            set_img_dirs.append(set_dir / 'basics')
            # split DFCs
            for card_info in set_info['cards']:
                card_name = card_info['name']
                if card_info.get('layout', 'normal') in {'double-faced', 'transform'} and card_info['names'][0] == card_name:
                    img_path = img_filename(card_name, set_img_dirs, count=card_count[card_name], original_name=card_info.get('originalName'))
                    print(f'[....] Opening DFC image for {card_name}...', end='', flush=True)
                    with PIL.Image.open(img_path) as dfc_image:
                        if dfc_image.size[0] < dfc_image.size[1]:
                            print(f' This is only the front face\r[ ** ]')
                            continue
                        if dfc_image.size == (752, 523):
                            front_image = dfc_image.crop((0, 0, 375, 523))
                            back_image = dfc_image.crop((377, 0, 752, 523))
                        else:
                            print('\r[!!!!]')
                            raise NotImplementedError(f"Don't know how to split DFC with dimensions {dfc_image.size[0]}×{dfc_image.size[1]}")
                    front_image.save(img_path.parent / f'{card_info["names"][0]}.png')
                    back_image.save(img_path.parent / f'{card_info["names"][1]}.png')
                    if img_path != img_path.parent / f'{card_info["names"][0]}.png':
                        img_path.unlink()
                    print(f' split successful\r[ ** ]')
            # upload images
            for card_info in set_info['cards']:
                card_name = card_info['name']
                card_id = card_info['number']
                for i in range(5):
                    try:
                        subprocess.run(['scp', str(img_filename(card_name, set_img_dirs, count=card_count[card_name], original_name=card_info.get('originalName'))), f'{os.environ.get("LORE_SEEKER_HOSTNAME", "laire")}:{REMOTE_STAGE / "frontend" / "public" / "cards" / set_code.lower() / (card_id + ".png")}'], check=True)
                    except subprocess.CalledProcessError:
                        if i < 4:
                            continue
                        else:
                            raise
                    else:
                        break
                card_count[card_name] += 1

def yesno(question):
    return choose(question, ['yes', 'no']) == 'yes'

if __name__ == '__main__':
    if sys.argv[1] in SUBCOMMANDS:
        result = SUBCOMMANDS[sys.argv[1]](*sys.argv[2:])
    else:
        sys.exit(f'[!!!!] No such subcommand. Available subcommands: {", ".join(sorted(SUBCOMMANDS))}')
    if isinstance(result, int):
        sys.exit(result)
    elif result is not None:
        print(result)
