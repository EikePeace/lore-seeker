#!/usr/bin/env ruby

require "fileutils"
require "json"
require "memoist"
require "pathname-glob"
require "pathname"
require "pry"

class SingleSetUpdater
  extend Memoist

  attr_reader :incoming_path, :current_path

  def initialize(incoming_path, current_path)
    @incoming_path = incoming_path
    @current_path = current_path
  end

  memoize def incoming_data
    JSON.parse(@incoming_path.read)
  end

  memoize def current_data
    JSON.parse(@current_path.read)
  end

  memoize def incoming_name
    incoming_data["name"]
  end

  memoize def current_name
    current_data["name"]
  end

  memoize def incoming_code
    incoming_data["code"]
  end

  memoize def current_code
    current_data["code"]
  end

  memoize def incoming_cards
    incoming_data["cards"].map{|c| [c["name"], c["number"]] }.sort
  end

  memoize def current_cards
    current_data["cards"].map{|c| [c["name"], c["number"]] }.sort
  end

  def call
    if current_path.exist?
      handle_update
    else
      handle_new
    end
  end

  def bad_foregin_only_sets
    %W[FBB 4BB REN RIN PSAL PS11]
  end

  def handle_new
    if incoming_data["isPartialPreview"]
      return [:spoiler, "#{incoming_data["cards"].size} / #{incoming_data["baseSetSize"]}"]
    end
    # We're actually OK with foreign promo sets
    return :drop if incoming_data["isForeignOnly"] and bad_foregin_only_sets.include?(incoming_code)
    # Just ignore it
    return :drop if incoming_code == "SUM"
    return :drop if incoming_code == "PSAL"
    # More reasons to delete ?
    :new
  end

  # Display reason for debugging
  def handle_update
    issues = []
    issues << :name if incoming_name != current_name
    issues << :code if incoming_code != current_code
    if incoming_cards != current_cards
      if current_cards.map(&:first) != incoming_cards.map(&:first)
        issues << :card_names
      else
        issues << :card_numbers
      end
    end
    return :update if issues.empty?
    return [:conflict, issues]
  end
end

class UpdateMtgjsonSets
  def current_dir
    Pathname(__dir__) + "../../data/sets"
  end

  def incoming_dir
    Pathname(__dir__) + "../../tmp/sets-incoming"
  end

  def incoming_files
    incoming_dir.glob("*.json")
  end

  def call
    incoming_files.each do |incoming_path|
      name = incoming_path.basename(".json").to_s
      current_path = current_dir + incoming_path.basename
      command, comment = SingleSetUpdater.new(incoming_path, current_path).call

      case command
      when :drop
        FileUtils.rm incoming_path, force: true #, verbose: true
      when :update
        FileUtils.mv incoming_path, current_path, force: true #, verbose: true
      when :conflict
        puts "#{name} - conflicting update (#{comment.inspect})"
      when :spoiler
        puts "#{name} - spoiler set (#{comment})"
      when :new
        puts "#{name} - new set"
      else
        raise
      end
    end
  end
end

UpdateMtgjsonSets.new.call
